# app/api/routers/

## Users

### 1. Сброс или изменение пароля пользователя АДМИНОМ
 _[Возможно, придётся делать, но очень нескоро. Это вторичная функция]_
<br> Добавить для админа либо функцию сброса пароля конкретного пользователя (не админа), либо функцию изменения пароля конкретного пользователя (не админа).
<br> В сущности, это будет одно и то же, ведь сброс пароля должен установить рандомно сгенерированный пароль, который нужно будет передать пользователю по почте. А это значит, что и админ узнает этот пароль.
<br> Вообще можно это записать в # TODO, ибо сейчас пока это нафиг не надо. Это вторичная функция.
- - - - - - - - - -
### 2.1 Получение пользователей по должности
 _[Возможно, придётся делать, но очень нескоро. Это вторичная функция]_
<br> Добавить новый эндпоинт и все соответствующие функции, чтобы админ мог получить всех пользователей определённой должности.
- - - - - - - - - -
### 2.2. Получение пользователей по номеру или телефону
 _[Скорее всего, придётся делать, так как функции уже есть]_
<br> У нас есть функции get_by_email и get_by_phone в user_repository.
<br> Почему нет соответствующих эндпоинтов в API? И соответствующих функций в user_service.py?

   <hr style="height:2.0px; border-width:0; background-color:red">

# app/services/

## auth_service.py

 _[Возможно, понадобится в будущем для валидации токена на стороне сервера]_
<br> Если появятся сценарии, где нужно будет программно декодировать токен вне стандартного потока зависимостей FastAPI (например, в WebSocket хендлере для аутентификации по токену, переданному не через HTTP заголовок, или в каком-то другом микросервисе, который должен валидировать токены, выданные этим), то эта функция может пригодиться.

```python
def decode_token(token: str) -> Optional[Dict[str, Any]]:
    """ Декодирует JWT токен и получает данные (payload) """
    try:
        payload = jwt.decode(
             token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM]
        )
        return payload
    except JWTError:
        return None
```

# app/api/routers/

## parameters.py

 _[Возможно, понадобится в будущем.]_ 
<br> На данный момент это абсолютно ненужный эндпоинт.

```python
@router.get("/{parameter_id}/details/", response_model=ParameterRead)
async def read_parameter_details(*, parameter_id: int, db: Session = Depends(deps.get_db),
                                 current_user: UserModel = Depends(deps.get_current_user)) -> Parameter:
    """ Получает детальную информацию о конкретном параметре.
    Доступ проверяется на уровне сервиса. """
    parameter = parameter_service.get_parameter_details(
        db=db, current_user=current_user, parameter_id=parameter_id
    )
    return parameter
```